{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Simple Config Builder","text":"<p>This is a simple tool to help you build a configuration file for your project.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install simple_config_builder\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>When writing your library configuration files are often a necessity.  Instead of using a dictionary or a class to store your configuration, you can build config classes using this tool.</p> <pre><code>from simple_config_builder import Configclass, Field\n\nclass MyConfig(Configclass):\n    name: str = \"John Doe\"\n    age: int = 30\n    is_student: bool = False\n    grades: int = Field(gt=0, lt=100)\n</code></pre> <p>This will create a class with the specified fields and default values and validation rules.</p> <p>For IO, you can use  <pre><code>from simple_config_builder.configparser import Configparser\nfrom simple_config_builder import Configclass, Field\n\n@configclass\nclass MyConfig:\n    name: str = \"John Doe\"\n    age: int = 30\n    is_student: bool = False\n    grades: int = Field(gt=0, lt=100, default=90)\n\n# Load and parse the configuration file\nconfig = Configparser(\"config.json\")\n\n# Save the configuration file\nconfig.save()\n\n# reload the configuration file\nconfig.reload()\n\n# Set a config object\nconfig['my_config'] = MyConfig(\"John Doe\", 30, False, 90)\n</code></pre></p> <p>Apart from that autosave and autoreload is supported. </p>"},{"location":"#callables","title":"Callables","text":"<p>You can also use callables as fields in the config class.  <pre><code>from simple_config_builder import Field, Configclass\nfrom collections.abc import Callable\n\n@configclass\nclass MyConfig:\n    name: str = \"John Doe\"\n    age: int = 30\n    is_student: bool = False\n    grades: int = Field(gt=0, lt=100, default=90)\n    student_name_calling: Callable\n</code></pre> The callables are saved in the configuration files as package.module name and function name. If the module is not in the python path, a file_path is saved additionally.</p> <pre><code>{\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"is_student\": false,\n    \"grades\": 90,\n    \"student_name_calling\": \n    {\n      \"module\": \"package.module\",\n      \"function\": \"function_name\",\n      \"file_path\": \"path/to/file\"\n    }\n}\n</code></pre>"},{"location":"#typing","title":"Typing","text":"<p>Because the Configclass is based on pydantic, you can use all the features of pydantic, like type hints, validation, and more. You can use the <code>Field</code> from pydantic to define constraints on the fields.</p> <pre><code>from simple_config_builder import Configclass\n\n\nclass MyConfig(Configclass):\n    name: str = \"John Doe\"\n    age: int = 30\n    is_student: bool = False\n    grades: int = config_field(gt=0, lt=100)\n\n\nc = MyConfig(\n    name=\"John Doe\",\n    age=30,\n    is_student=False,\n    grades=90\n)    \n\nc.name = \"Jane Doe\"\n\ndef my_function(config: Configclass):\n    print(config.name)\n\nmy_function(MyConfig())\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024-present jogehl joshuagehlen@hotmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"apis/config/","title":"Config","text":"<p>Implementation of the Configclass and the Registry.</p> <p>The Configclass are used to create a class with constraints on the fields. The constraints are defined using the Field from pydantic. The Configclass adds the following functionality:</p> <ul> <li>Registers the class in the ConfigClassRegistry</li> <li>Adds a _config_class_type attribute to the class</li> <li>Converts the class to a pyserde class for serialization and deserialization A class decorated with configclass fulfills the Configclass protocol.</li> </ul> Example <pre><code>from simple_config_builder import Configclass, Field\n\nclass MyClass(Configclass):\n    x:\n        int = Field(gt=0, lt=10)\n    y:\n        Literal[\"a\", \"b\", \"c\"] = Field(default=\"a\")\n\nmy_class: Configclass = MyClass(x=5, y=\"a\")\nmy_class.x = 10  # Raises ValueError\nmy_class.y = \"d\"  # Raises ValueError\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry","title":"<code>ConfigClassRegistry</code>","text":"<p>Registry to hold all registered classes.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>class ConfigClassRegistry:\n    \"\"\"Registry to hold all registered classes.\"\"\"\n\n    __registry: ClassVar = {}  # Class variable to hold the registry\n\n    @classmethod\n    def get_class_str_from_class(cls, class_to_register: type):\n        \"\"\"\n        Get the class string from a class.\n\n        The class string is the module and class name of the\n        class separated by a dot.\n\n        Example:\n            ```\n            class_to_register = MyClass\n            get_class_str_from_class(class_to_register)\n            # Returns: \"mymodule.MyClass\"\n            ```\n\n\n        Parameters\n        ----------\n        class_to_register: The class to get the class string from.\n        \"\"\"\n        return f\"{class_to_register.__module__}.{class_to_register.__name__}\"\n\n    @classmethod\n    def register[T](cls, class_to_register: type[T]):\n        \"\"\"\n        Register a class in the global registry.\n\n        Parameters\n        ----------\n        class_to_register: The class to register.\n\n        Raises\n        ------\n        ValueError: If the class is already registered.\n        \"\"\"\n        if class_to_register not in cls.__registry:\n            class_str = cls.get_class_str_from_class(class_to_register)\n            cls.__registry[class_str] = class_to_register\n        else:\n            exception_msg = (\n                f\"{cls.get_class_str_from_class(class_to_register)} \"\n                f\"is already registered.\"\n            )\n            raise ValueError(exception_msg)\n\n    @classmethod\n    def list_classes(cls) -&gt; list[str]:\n        \"\"\"\n        List all registered classes.\n\n        Returns\n        -------\n        A list of class strings of all registered classes.\n        \"\"\"\n        return list(cls.__registry.keys())\n\n    @classmethod\n    def is_registered(cls, class_to_register) -&gt; bool:\n        \"\"\"\n        Check if a class is already registered.\n\n        Parameters\n        ----------\n        class_to_register: The class to check.\n        \"\"\"\n        return (\n            cls.get_class_str_from_class(class_to_register) in cls.__registry\n        )\n\n    @classmethod\n    def get(cls, class_name) -&gt; Configclass:\n        \"\"\"\n        Get a class from the registry by name.\n\n        Parameters\n        ----------\n        class_name: The name of the class to get.\n\n        Raises\n        ------\n        ValueError: If the class is not registered.\n\n        Returns\n        -------\n        The class if it is registered.\n        \"\"\"\n        for class_to_register in cls.__registry:\n            if class_to_register == class_name:\n                return cls.__registry[class_to_register]\n        raise ValueError(f\"{class_name} is not registered.\")\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.get","title":"<code>get</code>  <code>classmethod</code>","text":"<p>Get a class from the registry by name.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.get--parameters","title":"Parameters","text":"<p>class_name: The name of the class to get.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.get--raises","title":"Raises","text":"<p>ValueError: If the class is not registered.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.get--returns","title":"Returns","text":"<p>The class if it is registered.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>@classmethod\ndef get(cls, class_name) -&gt; Configclass:\n    \"\"\"\n    Get a class from the registry by name.\n\n    Parameters\n    ----------\n    class_name: The name of the class to get.\n\n    Raises\n    ------\n    ValueError: If the class is not registered.\n\n    Returns\n    -------\n    The class if it is registered.\n    \"\"\"\n    for class_to_register in cls.__registry:\n        if class_to_register == class_name:\n            return cls.__registry[class_to_register]\n    raise ValueError(f\"{class_name} is not registered.\")\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.get_class_str_from_class","title":"<code>get_class_str_from_class</code>  <code>classmethod</code>","text":"<p>Get the class string from a class.</p> <p>The class string is the module and class name of the class separated by a dot.</p> Example <pre><code>class_to_register = MyClass\nget_class_str_from_class(class_to_register)\n# Returns: \"mymodule.MyClass\"\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.get_class_str_from_class--parameters","title":"Parameters","text":"<p>class_to_register: The class to get the class string from.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>@classmethod\ndef get_class_str_from_class(cls, class_to_register: type):\n    \"\"\"\n    Get the class string from a class.\n\n    The class string is the module and class name of the\n    class separated by a dot.\n\n    Example:\n        ```\n        class_to_register = MyClass\n        get_class_str_from_class(class_to_register)\n        # Returns: \"mymodule.MyClass\"\n        ```\n\n\n    Parameters\n    ----------\n    class_to_register: The class to get the class string from.\n    \"\"\"\n    return f\"{class_to_register.__module__}.{class_to_register.__name__}\"\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.is_registered","title":"<code>is_registered</code>  <code>classmethod</code>","text":"<p>Check if a class is already registered.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.is_registered--parameters","title":"Parameters","text":"<p>class_to_register: The class to check.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>@classmethod\ndef is_registered(cls, class_to_register) -&gt; bool:\n    \"\"\"\n    Check if a class is already registered.\n\n    Parameters\n    ----------\n    class_to_register: The class to check.\n    \"\"\"\n    return (\n        cls.get_class_str_from_class(class_to_register) in cls.__registry\n    )\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.list_classes","title":"<code>list_classes</code>  <code>classmethod</code>","text":"<p>List all registered classes.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.list_classes--returns","title":"Returns","text":"<p>A list of class strings of all registered classes.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>@classmethod\ndef list_classes(cls) -&gt; list[str]:\n    \"\"\"\n    List all registered classes.\n\n    Returns\n    -------\n    A list of class strings of all registered classes.\n    \"\"\"\n    return list(cls.__registry.keys())\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.register","title":"<code>register</code>  <code>classmethod</code>","text":"<p>Register a class in the global registry.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.register--parameters","title":"Parameters","text":"<p>class_to_register: The class to register.</p>"},{"location":"apis/config/#simple_config_builder.config.ConfigClassRegistry.register--raises","title":"Raises","text":"<p>ValueError: If the class is already registered.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>@classmethod\ndef register[T](cls, class_to_register: type[T]):\n    \"\"\"\n    Register a class in the global registry.\n\n    Parameters\n    ----------\n    class_to_register: The class to register.\n\n    Raises\n    ------\n    ValueError: If the class is already registered.\n    \"\"\"\n    if class_to_register not in cls.__registry:\n        class_str = cls.get_class_str_from_class(class_to_register)\n        cls.__registry[class_str] = class_to_register\n    else:\n        exception_msg = (\n            f\"{cls.get_class_str_from_class(class_to_register)} \"\n            f\"is already registered.\"\n        )\n        raise ValueError(exception_msg)\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.Configclass","title":"<code>Configclass</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configclass base class.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>class Configclass(BaseModel):\n    \"\"\"Configclass base class.\"\"\"\n\n    _config_class_type: str = PrivateAttr()\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        # Set _config_class_type to the path and class name of the class\n        self._config_class_type = (\n            f\"{self.__class__.__module__}.{self.__class__.__name__}\"\n        )\n\n    @model_serializer(mode=\"wrap\")\n    def _wrap_ser(self, handler: SerializerFunctionWrapHandler):\n        \"\"\"Serialize the Configclass instance.\"\"\"\n        # use standard pydantic serialization exclude callables\n        # and add the _config_class_type attribute\n\n        data: dict[str, Any] = {}\n\n        data[\"_config_class_type\"] = self._config_class_type\n\n        # Serialize callables to their string representation\n        for key, field_info in type(self).model_fields.items():\n            value = getattr(self, key)\n            if callable(value):\n                # try import the module\n                try:\n                    importlib.import_module(value.__module__)\n                    file_path = \"\"\n                except ImportError:\n                    file_path = value.__code__.co_filename\n                data[key] = {\n                    \"type\": \"callable\",\n                    \"module\": value.__module__,\n                    \"name\": value.__name__,\n                    \"file_path\": file_path,\n                }\n            else:\n                # Otherwise, use the standard serialization\n                data[key] = value\n\n        return data\n\n    @model_validator(\n        mode=\"before\",\n    )\n    @classmethod\n    def _wrap_val(cls, data: dict[str, Any], info) -&gt; dict[str, Any]:\n        for key, value in data.items():\n            if (\n                isinstance(value, dict)\n                and \"type\" in value\n                and value[\"type\"] == \"callable\"\n            ):\n                module = value[\"module\"]\n                name = value[\"name\"]\n                file_path = value.get(\"file_path\", \"\")\n                if file_path:\n                    spec = importlib.util.spec_from_file_location(\n                        name, file_path\n                    )\n                    if spec is None:\n                        msg = (\n                            f\"Could not find spec for module\"\n                            f\"{name} at {file_path}\"\n                        )\n                        raise ImportError(msg)\n                    module = importlib.util.module_from_spec(spec)\n                    if spec.loader is None:\n                        msg = f\"Could not load module\" f\"{name} at {file_path}\"\n                        raise ImportError(msg)\n                    spec.loader.exec_module(module)\n                else:\n                    module = importlib.import_module(module)\n                data[key] = getattr(module, name)\n        return data\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"\n        Initialize the subclass and register it in the ConfigClassRegistry.\n\n        This method is called when a class is defined that\n        inherits from Configclass.\n        It registers the class in the ConfigClassRegistry.\n        \"\"\"\n        ConfigClassRegistry.register(cls)\n        return super().__init_subclass__(**kwargs)\n\n    model_config = ConfigDict(\n        validate_assignment=True,\n    )\n</code></pre>"},{"location":"apis/config/#simple_config_builder.config.Configclass.__init_subclass__","title":"<code>__init_subclass__</code>","text":"<p>Initialize the subclass and register it in the ConfigClassRegistry.</p> <p>This method is called when a class is defined that inherits from Configclass. It registers the class in the ConfigClassRegistry.</p> Source code in <code>src/simple_config_builder/config.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"\n    Initialize the subclass and register it in the ConfigClassRegistry.\n\n    This method is called when a class is defined that\n    inherits from Configclass.\n    It registers the class in the ConfigClassRegistry.\n    \"\"\"\n    ConfigClassRegistry.register(cls)\n    return super().__init_subclass__(**kwargs)\n</code></pre>"},{"location":"apis/config_io/","title":"Config IO","text":"<p>The module contains the IO functions.</p> <p>The IO functions are used to read and write the configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.construct_config","title":"<code>construct_config</code>","text":"<p>Construct the configuration objects.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def construct_config(config_data: Any):\n    \"\"\"Construct the configuration objects.\"\"\"\n    # If the configuration data is not a dictionary,\n    if not isinstance(config_data, dict):\n        return config_data\n\n    # Recursively construct the configuration objects\n    # from the configuration dictionary.\n    for key, value in config_data.items():\n        if isinstance(value, dict):\n            config_data[key] = construct_config(value)\n        if isinstance(value, list):\n            for i, item in enumerate(value):\n                if isinstance(item, dict):\n                    value[i] = construct_config(item)\n        if isinstance(value, tuple):\n            value = list(value)\n            for i, item in enumerate(value):\n                if isinstance(item, dict):\n                    value[i] = construct_config(item)\n            config_data[key] = tuple(value)\n    if \"_config_class_type\" in config_data:\n        config_class_type = config_data[\"_config_class_type\"]\n        if not isinstance(config_class_type, str):\n            raise ValueError(\n                \"The _config_class_type must be a \"\n                \"string representing the class type.\"\n            )\n\n        # cut of the class name if it is a full path\n        if \".\" in config_class_type:\n            config_class_module = config_class_type.rsplit(\".\", 1)[0]\n        try:\n            importlib.import_module(config_class_module)\n        except ImportError:\n            raise ImportError(\n                f\"Could not import the module '{config_class_module}'. \"\n                \"Please make sure the module is installed and available \"\n                \"in the Python path.\"\n            )\n        try:\n            config_class = ConfigClassRegistry.get(config_class_type)\n            print(f\"Config class found: {config_class}\")\n        except ValueError:\n            raise ValueError(\n                f\"Please make sure the class '{config_class_type}' \"\n                f\"is in the module '{config_class_module}'.\"\n            )\n        del config_data[\"_config_class_type\"]\n\n        # Log the expected fields of the config class\n        expected_fields = set(config_class.__pydantic_fields__.keys())\n        print(f\"Expected fields for {config_class}: {expected_fields}\")\n\n        # Log the actual keys in the config data\n        actual_keys = set(config_data.keys())\n        print(f\"Actual keys in config data: {actual_keys}\")\n\n        # Check for mismatched keys\n        mismatched_keys = actual_keys - expected_fields\n        if mismatched_keys:\n            raise ValueError(\n                f\"Mismatched keys in config data: {mismatched_keys}. \"\n                f\"Expected fields: {expected_fields}\"\n            )\n        # Filter config_data to include only expected fields\n        filtered_config_data = {\n            key: value\n            for key, value in config_data.items()\n            if key in expected_fields\n        }\n        print(f\"Filtered config data: {filtered_config_data}\")\n\n        # Pass filtered_config_data as a single dictionary argument\n        return config_class.model_validate(filtered_config_data)\n    return config_data\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_config","title":"<code>parse_config</code>","text":"<p>Parse the configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_config--parameters","title":"Parameters","text":"<p>config_file: The configuration file path. config_type: The configuration file type.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_config--returns","title":"Returns","text":"<p>The configuration dictionary.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def parse_config(config_file: str, config_type: ConfigTypes) -&gt; dict:\n    \"\"\"\n    Parse the configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n    config_type: The configuration file type.\n\n    Returns\n    -------\n    The configuration dictionary.\n    \"\"\"\n    config_data_dct = {}\n    match config_type:\n        case ConfigTypes.JSON:\n            config_data_dct = parse_json(config_file)\n        case ConfigTypes.YAML:\n            config_data_dct = parse_yaml(config_file)\n        case ConfigTypes.TOML:\n            config_data_dct = parse_toml(config_file)\n        case _:\n            raise ValueError(\"The configuration type is not supported.\")\n    return construct_config(config_data_dct)\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_json","title":"<code>parse_json</code>","text":"<p>Parse the JSON configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_json--parameters","title":"Parameters","text":"<p>config_file: The configuration file path.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_json--returns","title":"Returns","text":"<p>The parsed json data.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def parse_json(config_file: str):\n    \"\"\"\n    Parse the JSON configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n\n    Returns\n    -------\n    The parsed json data.\n    \"\"\"\n    import json\n\n    with open(config_file, \"r\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_toml","title":"<code>parse_toml</code>","text":"<p>Parse the TOML configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_toml--parameters","title":"Parameters","text":"<p>config_file: The configuration file path.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_toml--returns","title":"Returns","text":"<p>The parsed toml data.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def parse_toml(config_file: str):\n    \"\"\"\n    Parse the TOML configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n\n    Returns\n    -------\n    The parsed toml data.\n    \"\"\"\n    import toml\n\n    with open(config_file, \"r\") as f:\n        return toml.load(f)\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_yaml","title":"<code>parse_yaml</code>","text":"<p>Parse the YAML configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_yaml--parameters","title":"Parameters","text":"<p>config_file: The configuration file path.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.parse_yaml--returns","title":"Returns","text":"<p>The parsed yaml data.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def parse_yaml(config_file: str):\n    \"\"\"\n    Parse the YAML configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n\n    Returns\n    -------\n    The parsed yaml data.\n    \"\"\"\n    with open(config_file, \"r\") as f:\n        import yaml\n\n        return yaml.load(f, Loader=yaml.FullLoader)\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.to_dict","title":"<code>to_dict</code>","text":"<p>Convert an object to a dictionary.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.to_dict--parameters","title":"Parameters","text":"<p>obj: The object to convert.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.to_dict--returns","title":"Returns","text":"<p>The converted dictionary.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def to_dict(obj: Any) -&gt; dict | list | tuple:\n    \"\"\"\n    Convert an object to a dictionary.\n\n    Parameters\n    ----------\n    obj: The object to convert.\n\n    Returns\n    -------\n    The converted dictionary.\n    \"\"\"\n    if isinstance(obj, BaseModel):\n        # If the object is a Pydantic model, convert it to a dictionary\n        return obj.model_dump()\n    if isinstance(obj, dict):\n        return {key: to_dict(value) for key, value in obj.items()}\n    if isinstance(obj, list):\n        return [to_dict(item) for item in obj]\n    if isinstance(obj, tuple):\n        return tuple(to_dict(item) for item in obj)\n    return obj\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_config","title":"<code>write_config</code>","text":"<p>Write the configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_config--parameters","title":"Parameters","text":"<p>config_file: The configuration file path. data: The configuration data. config_type: The configuration file type.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def write_config(config_file: str, data: dict, config_type: ConfigTypes):\n    \"\"\"\n    Write the configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n    data: The configuration data.\n    config_type: The configuration file type.\n    \"\"\"\n    # try to make the data to a dictionary\n    config_data = to_dict(data)\n    match config_type:\n        case ConfigTypes.JSON:\n            write_json(config_file, config_data)\n        case ConfigTypes.YAML:\n            write_yaml(config_file, config_data)\n        case ConfigTypes.TOML:\n            write_toml(config_file, config_data)\n        case _:\n            raise ValueError(\"The configuration type is not supported.\")\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_json","title":"<code>write_json</code>","text":"<p>Write the JSON configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_json--parameters","title":"Parameters","text":"<p>config_file: The configuration file path. config_data: The configuration data.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def write_json(config_file: str, config_data: dict | list | tuple):\n    \"\"\"\n    Write the JSON configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n    config_data: The configuration data.\n    \"\"\"\n    import json\n\n    with open(config_file, \"w\") as f:\n        json.dump(config_data, f, indent=4)\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_toml","title":"<code>write_toml</code>","text":"<p>Write the TOML configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_toml--parameters","title":"Parameters","text":"<p>config_file: The configuration file path. config_data: The configuration data.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def write_toml(config_file: str, config_data: dict | list | tuple):\n    \"\"\"\n    Write the TOML configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n    config_data: The configuration data.\n    \"\"\"\n    import toml\n\n    with open(config_file, \"w\") as f:\n        toml.dump(config_data, f)\n</code></pre>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_yaml","title":"<code>write_yaml</code>","text":"<p>Write the YAML configuration file.</p>"},{"location":"apis/config_io/#simple_config_builder.config_io.write_yaml--parameters","title":"Parameters","text":"<p>config_file: The configuration file path. config_data: The configuration data.</p> Source code in <code>src/simple_config_builder/config_io.py</code> <pre><code>def write_yaml(config_file: str, config_data: dict | list | tuple):\n    \"\"\"\n    Write the YAML configuration file.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n    config_data: The configuration data.\n    \"\"\"\n    import yaml\n\n    with open(config_file, \"w\") as f:\n        yaml.dump(config_data, f)\n</code></pre>"},{"location":"apis/config_types/","title":"Config Types","text":"<p>The module defines the configuration types using an enumeration.</p>"},{"location":"apis/config_types/#simple_config_builder.config_types.ConfigTypes","title":"<code>ConfigTypes</code>","text":"<p>               Bases: <code>Enum</code></p> <p>The enumeration of the configuration types.</p> <p>The enumeration defines the configuration types that are supported by the configuration manager. The configuration types are used to determine the format of the configuration file.</p> Source code in <code>src/simple_config_builder/config_types.py</code> <pre><code>class ConfigTypes(Enum):\n    \"\"\"\n    The enumeration of the configuration types.\n\n    The enumeration defines the configuration types that are supported by the\n    configuration manager. The configuration types are used to determine the\n    format of the configuration file.\n    \"\"\"\n\n    JSON = \"json\"\n    YAML = \"yaml\"\n    TOML = \"toml\"\n</code></pre>"},{"location":"apis/configparser/","title":"Configparser","text":"<p>The configparser module.</p> <p>The module contains the configparser class. The configparser class is used to parse the configuration file and construct the configuration objects. It gives the ability to autosave the configuration file when the configuration objects are updated.</p>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser","title":"<code>Configparser</code>","text":"<p>The Configparser class.</p> <p>The Configparser class is used to parse the configuration file and construct the configuration objects. It gives the ability to autosave the configuration file when the configuration objects are updated.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>class Configparser:\n    \"\"\"\n    The Configparser class.\n\n    The Configparser class is used to parse the configuration file and\n    construct the configuration objects. It gives the ability to autosave\n    the configuration file when the configuration objects are updated.\n    \"\"\"\n\n    def __init__(\n        self,\n        config_file: str,\n        config_type: ConfigTypes | None = None,\n        autosave: bool = False,\n        autoreload: bool = False,\n    ):\n        \"\"\"\n        Initialize the configparser.\n\n        Parameters\n        ----------\n        config_file: The configuration file path.\n        config_type: The configuration type. Defaults to None.\n        autosave: Autosave the configuration file. Defaults to False.\n        autoreload: Autoreload the configuration file. Defaults to False.\n\n        Raises\n        ------\n        ValueError: If the configuration type is not recognized.\n        ValueError: If the configuration type is not supported.\n        \"\"\"\n        self.config_file = config_file\n        self.config_type = config_type\n        self.autosave = autosave\n        self.autoreload = autoreload\n        if self.autoreload and self.autosave:\n            raise ValueError(\n                \"Autoreload and autosave cannot be enabled at the same time.\"\n            )\n\n        if self.config_type is None:\n            self.config_type = self._get_config_type()\n            if self.config_type is None:\n                raise ValueError(\"The configuration type is not recognized.\")\n        if self.config_type is None:\n            raise ValueError(\"The configuration type is not supported.\")\n        # first read\n        self.config_data = parse_config(self.config_file, self.config_type)\n        if self.autoreload:\n            self._auto_reload_config()\n        if self.autosave:\n            self._auto_save_config()\n\n    def _get_config_type(self) -&gt; ConfigTypes:\n        \"\"\"\n        Get the configuration type from the configuration file.\n\n        Returns\n        -------\n            The configuration type.\n        \"\"\"\n        if self.config_file.endswith(\".json\"):\n            return ConfigTypes.JSON\n        if self.config_file.endswith(\".yaml\"):\n            return ConfigTypes.YAML\n        if self.config_file.endswith(\".toml\"):\n            return ConfigTypes.TOML\n        raise ValueError(\"The configuration type is not supported.\")\n\n    def _auto_save_config(self):\n        \"\"\"Autosave the configuration file.\"\"\"\n        self._old_config_data = self.config_data\n\n        def _save_config():\n            if self.config_type is None:\n                return\n            if self._old_config_data != self.config_data:\n                write_config(\n                    self.config_file, self.config_data, self.config_type\n                )\n                self._old_config_data = self.config_data\n\n        Timer(1, _save_config).start()\n\n    def _auto_reload_config(self):\n        \"\"\"Autoreload the configuration file.\"\"\"\n\n        # Check for changes in the configuration file\n        def _reload_config():\n            if self.config_type is None:\n                return\n            new_config_data = parse_config(self.config_file, self.config_type)\n            if new_config_data != self.config_data:\n                self.config_data = new_config_data\n\n        Timer(1, _reload_config).start()\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value for the given key in the configuration data.\n\n        Parameters\n        ----------\n        key: The key in the configuration data.\n        value: The value to set for the key.\n        \"\"\"\n        self.config_data[key] = value\n\n    def __getitem__(self, key):\n        \"\"\"\n        Get the value for the given key in the configuration data.\n\n        Parameters\n        ----------\n        key: The key in the configuration data.\n\n        Returns\n        -------\n        The value for the key.\n        \"\"\"\n        return self.config_data[key]\n\n    def __delitem__(self, key):\n        \"\"\"Delete the key from the configuration data.\"\"\"\n        del self.config_data[key]\n\n    def save(self):\n        \"\"\"Save the configuration data to the configuration file.\"\"\"\n        if self.config_type is None:\n            return\n        write_config(self.config_file, self.config_data, self.config_type)\n\n    def reload(self):\n        \"\"\"Reload the configuration data from the configuration file.\"\"\"\n        if self.config_type is None:\n            return\n        self.config_data = parse_config(self.config_file, self.config_type)\n</code></pre>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__delitem__","title":"<code>__delitem__</code>","text":"<p>Delete the key from the configuration data.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>def __delitem__(self, key):\n    \"\"\"Delete the key from the configuration data.\"\"\"\n    del self.config_data[key]\n</code></pre>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__getitem__","title":"<code>__getitem__</code>","text":"<p>Get the value for the given key in the configuration data.</p>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__getitem__--parameters","title":"Parameters","text":"<p>key: The key in the configuration data.</p>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__getitem__--returns","title":"Returns","text":"<p>The value for the key.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"\n    Get the value for the given key in the configuration data.\n\n    Parameters\n    ----------\n    key: The key in the configuration data.\n\n    Returns\n    -------\n    The value for the key.\n    \"\"\"\n    return self.config_data[key]\n</code></pre>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__init__","title":"<code>__init__</code>","text":"<p>Initialize the configparser.</p>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__init__--parameters","title":"Parameters","text":"<p>config_file: The configuration file path. config_type: The configuration type. Defaults to None. autosave: Autosave the configuration file. Defaults to False. autoreload: Autoreload the configuration file. Defaults to False.</p>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__init__--raises","title":"Raises","text":"<p>ValueError: If the configuration type is not recognized. ValueError: If the configuration type is not supported.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>def __init__(\n    self,\n    config_file: str,\n    config_type: ConfigTypes | None = None,\n    autosave: bool = False,\n    autoreload: bool = False,\n):\n    \"\"\"\n    Initialize the configparser.\n\n    Parameters\n    ----------\n    config_file: The configuration file path.\n    config_type: The configuration type. Defaults to None.\n    autosave: Autosave the configuration file. Defaults to False.\n    autoreload: Autoreload the configuration file. Defaults to False.\n\n    Raises\n    ------\n    ValueError: If the configuration type is not recognized.\n    ValueError: If the configuration type is not supported.\n    \"\"\"\n    self.config_file = config_file\n    self.config_type = config_type\n    self.autosave = autosave\n    self.autoreload = autoreload\n    if self.autoreload and self.autosave:\n        raise ValueError(\n            \"Autoreload and autosave cannot be enabled at the same time.\"\n        )\n\n    if self.config_type is None:\n        self.config_type = self._get_config_type()\n        if self.config_type is None:\n            raise ValueError(\"The configuration type is not recognized.\")\n    if self.config_type is None:\n        raise ValueError(\"The configuration type is not supported.\")\n    # first read\n    self.config_data = parse_config(self.config_file, self.config_type)\n    if self.autoreload:\n        self._auto_reload_config()\n    if self.autosave:\n        self._auto_save_config()\n</code></pre>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__setitem__","title":"<code>__setitem__</code>","text":"<p>Set the value for the given key in the configuration data.</p>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.__setitem__--parameters","title":"Parameters","text":"<p>key: The key in the configuration data. value: The value to set for the key.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"\n    Set the value for the given key in the configuration data.\n\n    Parameters\n    ----------\n    key: The key in the configuration data.\n    value: The value to set for the key.\n    \"\"\"\n    self.config_data[key] = value\n</code></pre>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.reload","title":"<code>reload</code>","text":"<p>Reload the configuration data from the configuration file.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>def reload(self):\n    \"\"\"Reload the configuration data from the configuration file.\"\"\"\n    if self.config_type is None:\n        return\n    self.config_data = parse_config(self.config_file, self.config_type)\n</code></pre>"},{"location":"apis/configparser/#simple_config_builder.configparser.Configparser.save","title":"<code>save</code>","text":"<p>Save the configuration data to the configuration file.</p> Source code in <code>src/simple_config_builder/configparser.py</code> <pre><code>def save(self):\n    \"\"\"Save the configuration data to the configuration file.\"\"\"\n    if self.config_type is None:\n        return\n    write_config(self.config_file, self.config_data, self.config_type)\n</code></pre>"},{"location":"apis/utils/","title":"Utils","text":"<p>Utils for the config module.</p>"},{"location":"apis/utils/#simple_config_builder.utils.import_modules_from_directory","title":"<code>import_modules_from_directory</code>","text":"<p>Import and check fo Configclass subclasses in the given directory.</p>"},{"location":"apis/utils/#simple_config_builder.utils.import_modules_from_directory--parameters","title":"Parameters","text":"<p>directory: str</p> Source code in <code>src/simple_config_builder/utils.py</code> <pre><code>def import_modules_from_directory(directory: str):\n    \"\"\"\n    Import and check fo Configclass subclasses in the given directory.\n\n    Parameters\n    ----------\n    directory: str\n    \"\"\"\n    # Iterate over all files and subdirectories in the given directory\n    import os\n    import importlib.util\n\n    for dirpath, dirnames, filenames in os.walk(directory):\n        for filename in filenames:\n            # Check if the file is a Python file\n            if filename.endswith(\".py\") and filename != \"__init__.py\":\n                # Get the module name (without .py extension)\n                module_name = filename[:-3]\n\n                # Create the full module path\n                module_path = os.path.join(dirpath, filename)\n\n                with open(module_path, \"r\") as file:\n                    content = file.read()\n                    if \"Configclass\" in content:\n                        # Dynamically import the module\n                        try:\n                            spec = importlib.util.spec_from_file_location(\n                                module_name, module_path\n                            )\n                            if spec is None:\n                                raise ImportError(\n                                    f\"Error while importing \"\n                                    f\"module {module_name}: \"\n                                    f\"spec is None\"\n                                )\n                            module = importlib.util.module_from_spec(spec)\n                            if spec.loader is None:\n                                raise ImportError(\n                                    f\"Error while importing \"\n                                    f\"module {module_name}: \"\n                                    f\"loader is None\"\n                                )\n                            spec.loader.exec_module(module)\n                        except Exception as e:\n                            raise ImportError(\n                                f\"Error while importing \"\n                                f\"module {module_name}: {e}\"\n                            )\n</code></pre>"}]}